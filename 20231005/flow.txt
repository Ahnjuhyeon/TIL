**2. 나는 hook함수의 종류와 기능, 어느 순간 사용 해야할지 정의할 수 있다**

(1) 각 훅함수의 장단점과 개념, 사용해야하는 순간을 한글로 정의해보세요
useState
- 초기 상태의 값이 있고 그 상태를 바꿀때! 리랜더링 된다!
- 내가 원하는 시점에 ui를 변경할때

useRef
- 랜더가 되어도 값이 유지가 된다! (원래라면 값이 초기화!)
- 태그에 접근이 가능하다!
- 랜더가 되어도 값이 유지되는걸 원할때 

useEffect
- 처음 화면이(컴포넌트) 열렸을때 실행
- 의존성 배열에 값을 넣으면 특정 값이 바뀌었을때 실행하고 싶은 함수를 실행!

useMemo
-> 어떤 조건이 만족됐을 때만
-> 의존성 배열에 값이 있으면 그 값 ( 함수만 ) 호출 될 때만 useMemo 함수가 변경 된다 ..

const 변수명 = (()=>{
    console.log()
},[호출시 변경된 함수])



useCallback
useMemo랑 차이가 뭐지.. 
값을 캐싱해두고 내가 원하는 특정 함수의 값이 바뀔때 쓰인다고..?
다들 그런것 같은데..

(2) 1번의 예시를 모두 코드로 직접 구현해보세요
내파일에 있다 useCallback 빼고...

----------------------------------------------------------------------------------------------------

**3. 나는 전역 상태 관리를 하는 방법의 종류와 어느 순간 전역 상태를 관리해야할지 단순 설명뿐이 아니라 판단할 수 있다.**

(1) 전역 상태로 전환 해야하는 순간은 언제이며, 전역 상태하지 않은 사례와 전역 상태 관리한 사례를 코드로 구현하여 비교해보세요.
    프롭스 드릴링이 일어날때 , 
    부모는 상태를 몰라도 되는 상태일 때,독립...

전역 상태하지 않은 사례 => 지금 내가 문제 5번 이 전역상태를 하지 않았을 때 

index.js
  <div>
        <AddTodo post={posts} setPost={setPosts} />
        {posts.map((post) => (
          <OnePost post={post} posts={posts} setPosts={setPosts} />
        ))}
      </div>


OnePost.js
const OnePost = ({ post, posts, setPosts }) => {
    ....
    return
    ...
}

전역 상태 관리한 사례

context 나 다른 라이브러리들을 사용하여 
context.js

  const { post, addPostShow, setAddPostShow } = usePost(); 

----------------------------------------------------------------------------------------------------

**4.  나는 CRUD를 활용한 상태 변경과 UI 변경 시점에 따른 리랜더링을 자유롭게 다룰 수 있다.**

(1) 아래 데이터를 주제로 CRUD를 진행해보세요
        
        const posts = [
            {
                id: 1,
                title: "",
                content: "",
            },
            {},
            {}
        ]

----------------------------------------------------------------------------------------------------

**5. 나는 중첩 객체 배열의 CRUD와 상태 변화를 자유롭게 다룰 수 있다.**

(1) 중첩 객체배열에서 상태 변화가 정상적으로 작동하지 않은 경우에 대해서 정의해보세요
(2) 아래의 데이터를 토대로 Comment를 CRUD 해보세요

            const post = {
                id: 1,
                title: "",
                content: "",
                Comments : [
                    {
                        id:1,
                        title: "",
                        content: ""
                    },
                    {},
                    {}
                ]
            }

----------------------------------------------------------------------------------------------------

**6. 나는 재사용이 가능한 컴포넌트를 만들 수 있는 방법을 알고 있으며 만들 수 있다.**

(1) 어느 곳에서든 재사용이 가능한 컴포넌트를 만드는 기준은 무엇이며, 어떻게 구현할 수 있을까요?

   하나에서 관리를 하면, 관리 및 유지하기 쉽고, 수정 및 업데이트가 매우 쉽고 같은말이구나..
   하나에 로직에서 수정 및 관리만 하면 기존에 임폴트 된 가지처럼 뻗은 다른 컴포넌트들이 모두 정보가 업데이트되니까요!
   여기저기 공통된 로직들을 독립 된 컴포넌트로 만드는 것이 기준이다!? 

   구현 방법은 
   context도 있고
   reducer redux 등 여러가지의 라이브러리들도 있습니다..

(2) 공용 컴포넌트 Select, Button, Input, Modal을 만들어보세요.

----------------------------------------------------------------------------------------------------

**7. 나는 Promise와 async/await을 왜 사용해야하는지 알고 있으며, 예외처리를 할 수 있다.**

(1) 각각 Promise와 async/await은 언제 사용해야할까요?
(2) 이를 활용한 간단한 에제를 만들어보세요
(3) Promise와 async/await의 예외처리는 어떻게 다를까요?

----------------------------------------------------------------------------------------------------

**8. 나는 비동기를 명확하게 이해하고 있으며, 처리 순서가 어떻게 진행되는지 알고 있다.**

(1) 비동기는 이벤트루프를 통해 실행됩니다.
(2) 이벤트루프 내에서 비동기는 언제 실행될까요?

----------------------------------------------------------------------------------------------------