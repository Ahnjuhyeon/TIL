**2. 나는 hook함수의 종류와 기능, 어느 순간 사용 해야할지 정의할 수 있다**

(1) 각 훅함수의 장단점과 개념, 사용해야하는 순간을 한글로 정의해보세요
useState
- 초기 상태의 값이 있고 그 상태를 바꿀때! 리랜더링 된다!
- 내가 원하는 시점에 ui를 변경할때

useRef
- 랜더가 되어도 값이 유지가 된다! (원래라면 값이 초기화!)
- 태그에 접근이 가능하다!
- 랜더가 되어도 값이 유지되는걸 원할때 

useEffect
- 처음 화면이(컴포넌트) 열렸을때 실행
- 의존성 배열에 값을 넣으면 특정 값이 바뀌었을때 실행하고 싶은 함수를 실행!

useMemo
-> 어떤 조건이 만족됐을 때만
-> 의존성 배열에 값이 있으면 그 값 ( 함수만 ) 호출 될 때만 useMemo 함수가 변경 된다 ..

const 변수명 = (()=>{
    console.log()
},[호출시 변경된 함수])



useCallback
useMemo랑 차이가 뭐지.. 
값을 캐싱해두고 내가 원하는 특정 함수의 값이 바뀔때 쓰인다고..?
다들 그런것 같은데..

(2) 1번의 예시를 모두 코드로 직접 구현해보세요
내파일에 있다 useCallback 빼고...

----------------------------------------------------------------------------------------------------

**3. 나는 전역 상태 관리를 하는 방법의 종류와 어느 순간 전역 상태를 관리해야할지 단순 설명뿐이 아니라 판단할 수 있다.**

(1) 전역 상태로 전환 해야하는 순간은 언제이며, 전역 상태하지 않은 사례와 전역 상태 관리한 사례를 코드로 구현하여 비교해보세요.
    프롭스 드릴링이 일어날때 , 
    부모는 상태를 몰라도 되는 상태일 때,독립...

전역 상태하지 않은 사례 => 지금 내가 문제 5번 이 전역상태를 하지 않았을 때 

index.js
  <div>
        <AddTodo post={posts} setPost={setPosts} />
        {posts.map((post) => (
          <OnePost post={post} posts={posts} setPosts={setPosts} />
        ))}
      </div>


OnePost.js
const OnePost = ({ post, posts, setPosts }) => {
    ....
    return
    ...
}

전역 상태 관리한 사례

context 나 다른 라이브러리들을 사용하여 
context.js

  const { post, addPostShow, setAddPostShow } = usePost(); 

----------------------------------------------------------------------------------------------------

**4.  나는 CRUD를 활용한 상태 변경과 UI 변경 시점에 따른 리랜더링을 자유롭게 다룰 수 있다.**

(1) 아래 데이터를 주제로 CRUD를 진행해보세요
        
        const posts = [
            {
                id: 1,
                title: "",
                content: "",
            },
            {},
            {}
        ]

----------------------------------------------------------------------------------------------------

**5. 나는 중첩 객체 배열의 CRUD와 상태 변화를 자유롭게 다룰 수 있다.**

(1) 중첩 객체배열에서 상태 변화가 정상적으로 작동하지 않은 경우에 대해서 정의해보세요
(2) 아래의 데이터를 토대로 Comment를 CRUD 해보세요

            const post = {
                id: 1,
                title: "",
                content: "",
                Comments : [
                    {
                        id:1,
                        title: "",
                        content: ""
                    },
                    {},
                    {}
                ]
            }

----------------------------------------------------------------------------------------------------

**6. 나는 재사용이 가능한 컴포넌트를 만들 수 있는 방법을 알고 있으며 만들 수 있다.**

(1) 어느 곳에서든 재사용이 가능한 컴포넌트를 만드는 기준은 무엇이며, 어떻게 구현할 수 있을까요?

   하나에서 관리를 하면, 관리 및 유지하기 쉽고, 수정 및 업데이트가 매우 쉽고 같은말이구나..
   하나에 로직에서 수정 및 관리만 하면 기존에 임폴트 된 가지처럼 뻗은 다른 컴포넌트들이 모두 정보가 업데이트되니까요!
   여기저기 공통된 로직들을 독립 된 컴포넌트로 만드는 것이 기준이다!? 

   구현 방법은 
   context도 있고
   reducer redux 등 여러가지의 라이브러리들도 있습니다..

(2) 공용 컴포넌트 Select, Button, Input, Modal을 만들어보세요.
Button 만들어 봤스비다 

----------------------------------------------------------------------------------------------------

**7. 나는 Promise와 async/await을 왜 사용해야하는지 알고 있으며, 예외처리를 할 수 있다.**
Promise는 then() 과 catch() 써야 결과값을 콘솔이든 뭐든 받을 수 있음 ?

Promise와 async/await 차이점은
promise는  대기(pending), 이행(fulfilled), 거부(rejected) 

throw => reject?


async/await
함수에 async 키위드를 붙입니다.
new Promise... 부분을 없애고 executor 본문 내용만 남깁니다.
resolve(value); 부분을 return value; 로 변경합니다.
reject(new Error(…)); 부분을 throw new Error(…); 로 수정합니다.



(1) 각각 Promise와 async/await은 언제 사용해야할까요?

(2) 이를 활용한 간단한 에제를 만들어보세요
const condition = true;
const promise = new Promise((resolve, reject) => {
  if (condition) {
    resolve('resolved');
  } else {
    reject('rejected');
  }
});

promise
  .then((res) => {
    console.log(res);
  })
  .catch((error) => {
    console.error(error);
  });

  직접따라해보고 잘 이해가 됐던 


  async / await

(async () => {
  const condition = true;
  const promise = new Promise((resolve, reject) => {
    if (condition) {
      resolve('resolved');
    } else {
      reject('rejected');
    }
  });

  try {
    const result = await promise;
    console.log(result);
  } catch (err) {
    console.error(err);
  }
})();

(3) Promise와 async/await의 예외처리는 어떻게 다를까요?

1. Promise는 reject로 예외 처리 할 수 있다.
function myPromiseErrorFun() {
  return new Promise((_, reject) => {
    reject('myPromiseError!');
  });
}
const resultPromise = myPromiseErrorFun().catch((e) => {
  console.error(e);
});
2. async는 throw로 예외 처리 할 수 있다.
async function myAsyncErrorFun() {
  throw 'myAsyncError';
}
const resultAsync = myAsyncErrorFun().catch((e) => {
  console.error(e);
});
----------------------------------------------------------------------------------------------------

**8. 나는 비동기를 명확하게 이해하고 있으며, 처리 순서가 어떻게 진행되는지 알고 있다.**

(1) 비동기는 이벤트루프를 통해 실행됩니다.
(2) 이벤트루프 내에서 비동기는 언제 실행될까요?
    콜스택에서 함수를 push-pop해주고 
    비동기일때는 비동기의 콜백함수와 타이머를 백그라운드로 이동
    이동한 뒤에는 타이머 시간이 되면 태스크 큐로 보내준다
    이벤트 루프라는 기능은 
    앞서 동기적으로 처리할 함수들을 모두 콜스택으로 처리해준 뒤 
    아무것도 없다면 태스크 큐에서 비동기를 받아 콜스택으로 보내주며 실행된다


콜스택 => (실행 컨텍스트)
        함수를 호출하게 되면 콜스택으로 들어간다(push) 함수가 종료되면 제거(pop)
Web API => (feat.백그라운드)
태스크 큐 => 비동기 일때는 비동기 함수의 콜백 함수를 보관해주는 역할, 이 콜백 함수들을 보관해주며 이벤트 루프가 콜백 함수를 가져가기를 기다린다.
이벤트루프 => 콜스택에서 동기적인 push와 pop을 하고 아무것도 없다면 태스크큐에서 비동기인 콜백함수를 꺼내서 콜스택으로 보내주는 역할

동기적일때는 콜스택에서 push와 pop까지
비동기일경우 콜스택에서 Web API로 


web API란 브라우저에서 제공하는 API로써 setTimeout,이벤트 핸들러,ajax 요청과 같은 함수이다.이들은 모두 비동기 함수이다.

그리고 이들은 백그라운드내에서 동시에 실행될 수 있다.

이부분을 잘 모르겠는데  동시가 실행한다는게 
동시에 태스크큐에 보관하다가 동시에 이벤트 루프로 보낸다는 건가?
 콜백 함수가 동시에 이루어진다는 것은 아니다. 요청과 응답은 동시에 이뤄질 수 있다...?


참조
https://velog.io/@kcj_dev96/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%ACWeb-API-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%ED%83%9C%EC%8A%A4%ED%81%AC-%ED%81%90

----------------------------------------------------------------------------------------------------

참조
https://velog.io/@kykim_dev/%EA%B4%80%EC%8B%AC%EC%82%AC%EC%9D%98-%EB%B6%84%EB%A6%ACSeparation-of-Concerns-SoC%EC%99%80-Custom-Hook

**9. 나는 관심사 분리가 무엇인지 알고 있으며, 어느 순간 관심사를 분리해야하는지 알고 있다.**

(1) 관심사 분리는 무엇이며 언제해야할까요?
    한번에 한가지의 걱정만 하도록 이라는 말이 컴퓨터 공학에서 나온말이며 이를 관심사의 분리라고 한다 
    하나의 컴포넌트에게 너무 많은 일을 주게된다면 그 코드를 읽는 사람은 어려워한다
    그래서 하나의 컴포넌트의 하나의 일만 주어 그 일만 충실하게 해결하도록 해줘야한다 
    관심사 분리의 방법중 하나가 커스텀 훅도 될수 있는 것 같군

(2) 우리가 수업 중에 진행했던 내용 중 관심사를 분리한 내용에 대해서 생각해보세요
    수정이나 삭제 로직도 그 기능만 하도록 파일을 따로 만들어주었고, 그 파일자체도 그 수정, 삭제만 가능한 폴더에 있었다.
    api를 폴더를 만들었을때도 api의 주소 값만 저장해놓는 파일만 따로 저장


(3) 대표적 예시의 Custom Hook을 한가지 구현해보세요. useInputs 제외
    아 여기 써있었네..

    useModal 만들어 봤습니다.. 이해는 되는데 더 만들어볼게요 


----------------------------------------------------------------------------------------------------

**10. 나는 백엔드에서 데이터 패칭을 할 수 있으며 이를 UI에 랜더할 수 있다.**




(1) method get, post의 차이를 한글로 정의해보세요
(2) get에서 URL로 데이터를 전달할 수 있는 방법은 무엇이 있으며 
	  이를 fetch 혹은 axios를 활용해 전달하려면 어떻게 해야할까요

(3) https://jsonplaceholder.typicode.com 을 활용해 위의 예시를 직접 구현해보세요
        - (2)의 경우 데이터 (3)의 주소에 필요하지 않더라도 전달하는 방법을 코드로 구현해보세요. 
					동작에 필요 없다면 주석처리


----------------------------------------------------------------------------------------------------

**11. 나는 주소(URL)에 정보를 담을 수 있으며, 이를 활용하는 훅함수를 알고 있다.**